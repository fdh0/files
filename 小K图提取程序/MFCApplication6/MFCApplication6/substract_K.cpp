#include "stdafx.h"
///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 17.12
///////////////////////////////////////////////////////////////////////////////



#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#  if defined(__linux__) && !defined(__arm__) && !defined(NO_EXPORT_APP_MAIN)
#    include <X11/Xlib.h>
#  endif
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#  include <stdio.h>
#  include <HALCON/HpThread.h>
#  include <CoreFoundation/CFRunLoop.h>
#endif



using namespace HalconCpp;

// Procedure declarations 
// External procedures 
// Chapter: Develop
// Short Description: Open a new graphics window that preserves the aspect ratio of the given image. 
void dev_open_window_fit_image (HObject ho_Image, HTuple hv_Row, HTuple hv_Column, 
    HTuple hv_WidthLimit, HTuple hv_HeightLimit, HTuple *hv_WindowHandle);

// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, HTuple hv_Bold, 
    HTuple hv_Slant);

// Procedures 
// External procedures 
// Chapter: Develop
// Short Description: Open a new graphics window that preserves the aspect ratio of the given image. 
void dev_open_window_fit_image (HObject ho_Image, HTuple hv_Row, HTuple hv_Column, 
    HTuple hv_WidthLimit, HTuple hv_HeightLimit, HTuple *hv_WindowHandle)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_MinWidth, hv_MaxWidth, hv_MinHeight;
  HTuple  hv_MaxHeight, hv_ResizeFactor, hv_ImageWidth, hv_ImageHeight;
  HTuple  hv_TempWidth, hv_TempHeight, hv_WindowWidth, hv_WindowHeight;

  //This procedure opens a new graphics window and adjusts the size
  //such that it fits into the limits specified by WidthLimit
  //and HeightLimit, but also maintains the correct image aspect ratio.
  //
  //If it is impossible to match the minimum and maximum extent requirements
  //at the same time (f.e. if the image is very long but narrow),
  //the maximum value gets a higher priority,
  //
  //Parse input tuple WidthLimit
  if (0 != (HTuple((hv_WidthLimit.TupleLength())==0).TupleOr(hv_WidthLimit<0)))
  {
    hv_MinWidth = 500;
    hv_MaxWidth = 800;
  }
  else if (0 != ((hv_WidthLimit.TupleLength())==1))
  {
    hv_MinWidth = 0;
    hv_MaxWidth = hv_WidthLimit;
  }
  else
  {
    hv_MinWidth = ((const HTuple&)hv_WidthLimit)[0];
    hv_MaxWidth = ((const HTuple&)hv_WidthLimit)[1];
  }
  //Parse input tuple HeightLimit
  if (0 != (HTuple((hv_HeightLimit.TupleLength())==0).TupleOr(hv_HeightLimit<0)))
  {
    hv_MinHeight = 400;
    hv_MaxHeight = 600;
  }
  else if (0 != ((hv_HeightLimit.TupleLength())==1))
  {
    hv_MinHeight = 0;
    hv_MaxHeight = hv_HeightLimit;
  }
  else
  {
    hv_MinHeight = ((const HTuple&)hv_HeightLimit)[0];
    hv_MaxHeight = ((const HTuple&)hv_HeightLimit)[1];
  }
  //
  //Test, if window size has to be changed.
  hv_ResizeFactor = 1;
  GetImageSize(ho_Image, &hv_ImageWidth, &hv_ImageHeight);
  //First, expand window to the minimum extents (if necessary).
  if (0 != (HTuple(hv_MinWidth>hv_ImageWidth).TupleOr(hv_MinHeight>hv_ImageHeight)))
  {
    hv_ResizeFactor = (((hv_MinWidth.TupleReal())/hv_ImageWidth).TupleConcat((hv_MinHeight.TupleReal())/hv_ImageHeight)).TupleMax();
  }
  hv_TempWidth = hv_ImageWidth*hv_ResizeFactor;
  hv_TempHeight = hv_ImageHeight*hv_ResizeFactor;
  //Then, shrink window to maximum extents (if necessary).
  if (0 != (HTuple(hv_MaxWidth<hv_TempWidth).TupleOr(hv_MaxHeight<hv_TempHeight)))
  {
    hv_ResizeFactor = hv_ResizeFactor*((((hv_MaxWidth.TupleReal())/hv_TempWidth).TupleConcat((hv_MaxHeight.TupleReal())/hv_TempHeight)).TupleMin());
  }
  hv_WindowWidth = hv_ImageWidth*hv_ResizeFactor;
  hv_WindowHeight = hv_ImageHeight*hv_ResizeFactor;
  //Resize window
  SetWindowAttr("background_color","black");
  OpenWindow(hv_Row,hv_Column,hv_WindowWidth,hv_WindowHeight,0,"visible","",&(*hv_WindowHandle));
  HDevWindowStack::Push((*hv_WindowHandle));
  if (HDevWindowStack::IsOpen())
    SetPart(HDevWindowStack::GetActive(),0, 0, hv_ImageHeight-1, hv_ImageWidth-1);
  return;
}

// Chapter: Graphics / Text
// Short Description: Set font independent of OS 
void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, HTuple hv_Bold, 
    HTuple hv_Slant)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_OS, hv_Fonts, hv_Style, hv_Exception;
  HTuple  hv_AvailableFonts, hv_Fdx, hv_Indices;

  //This procedure sets the text font of the current window with
  //the specified attributes.
  //
  //Input parameters:
  //WindowHandle: The graphics window for which the font will be set
  //Size: The font size. If Size=-1, the default of 16 is used.
  //Bold: If set to 'true', a bold font is used
  //Slant: If set to 'true', a slanted font is used
  //
  GetSystem("operating_system", &hv_OS);
  // dev_get_preferences(...); only in hdevelop
  // dev_set_preferences(...); only in hdevelop
  if (0 != (HTuple(hv_Size==HTuple()).TupleOr(hv_Size==-1)))
  {
    hv_Size = 16;
  }
  if (0 != ((hv_OS.TupleSubstr(0,2))==HTuple("Win")))
  {
    //Restore previous behaviour
    hv_Size = (1.13677*hv_Size).TupleInt();
  }
  else
  {
    hv_Size = hv_Size.TupleInt();
  }
  if (0 != (hv_Font==HTuple("Courier")))
  {
    hv_Fonts.Clear();
    hv_Fonts[0] = "Courier";
    hv_Fonts[1] = "Courier 10 Pitch";
    hv_Fonts[2] = "Courier New";
    hv_Fonts[3] = "CourierNew";
    hv_Fonts[4] = "Liberation Mono";
  }
  else if (0 != (hv_Font==HTuple("mono")))
  {
    hv_Fonts.Clear();
    hv_Fonts[0] = "Consolas";
    hv_Fonts[1] = "Menlo";
    hv_Fonts[2] = "Courier";
    hv_Fonts[3] = "Courier 10 Pitch";
    hv_Fonts[4] = "FreeMono";
    hv_Fonts[5] = "Liberation Mono";
  }
  else if (0 != (hv_Font==HTuple("sans")))
  {
    hv_Fonts.Clear();
    hv_Fonts[0] = "Luxi Sans";
    hv_Fonts[1] = "DejaVu Sans";
    hv_Fonts[2] = "FreeSans";
    hv_Fonts[3] = "Arial";
    hv_Fonts[4] = "Liberation Sans";
  }
  else if (0 != (hv_Font==HTuple("serif")))
  {
    hv_Fonts.Clear();
    hv_Fonts[0] = "Times New Roman";
    hv_Fonts[1] = "Luxi Serif";
    hv_Fonts[2] = "DejaVu Serif";
    hv_Fonts[3] = "FreeSerif";
    hv_Fonts[4] = "Utopia";
    hv_Fonts[5] = "Liberation Serif";
  }
  else
  {
    hv_Fonts = hv_Font;
  }
  hv_Style = "";
  if (0 != (hv_Bold==HTuple("true")))
  {
    hv_Style += HTuple("Bold");
  }
  else if (0 != (hv_Bold!=HTuple("false")))
  {
    hv_Exception = "Wrong value of control parameter Bold";
    throw HException(hv_Exception);
  }
  if (0 != (hv_Slant==HTuple("true")))
  {
    hv_Style += HTuple("Italic");
  }
  else if (0 != (hv_Slant!=HTuple("false")))
  {
    hv_Exception = "Wrong value of control parameter Slant";
    throw HException(hv_Exception);
  }
  if (0 != (hv_Style==HTuple("")))
  {
    hv_Style = "Normal";
  }
  QueryFont(hv_WindowHandle, &hv_AvailableFonts);
  hv_Font = "";
  {
  HTuple end_val50 = (hv_Fonts.TupleLength())-1;
  HTuple step_val50 = 1;
  for (hv_Fdx=0; hv_Fdx.Continue(end_val50, step_val50); hv_Fdx += step_val50)
  {
    hv_Indices = hv_AvailableFonts.TupleFind(HTuple(hv_Fonts[hv_Fdx]));
    if (0 != ((hv_Indices.TupleLength())>0))
    {
      if (0 != (HTuple(hv_Indices[0])>=0))
      {
        hv_Font = HTuple(hv_Fonts[hv_Fdx]);
        break;
      }
    }
  }
  }
  if (0 != (hv_Font==HTuple("")))
  {
    throw HException("Wrong value of control parameter Font");
  }
  hv_Font = (((hv_Font+"-")+hv_Style)+"-")+hv_Size;
  SetFont(hv_WindowHandle, hv_Font);
  // dev_set_preferences(...); only in hdevelop
  return;
}

#ifndef NO_EXPORT_MAIN
// Main procedure 
void action()
{

  // Local iconic variables
  HObject  ho_Image, ho_GrayImage, ho_Rectangle1;
  HObject  ho_ImageReduced, ho_ImagePart1, ho_Rectangle2, ho_ImageReduced1;
  HObject  ho_ImagePart2, ho_Rectangle3, ho_ImageReduced2;
  HObject  ho_ImagePart3, ho_ImageSub, ho_ImageSub_1, ho_ImageSub_2;
  HObject  ho_ImageResult, ho_ImageResult1, ho_GraySub, ho_ImageEmphasize;
  HObject  ho_ImageReduced3, ho_Rectangle4, ho_ImageReduced4;
  HObject  ho_ImagePart4, ho_Rectangle5, ho_ImageReduced5;
  HObject  ho_ImagePart5, ho_ImageSub2, ho_ImageSub2_1, ho_ImageSub2_2;
  HObject  ho_ImageResult_2, ho_ImageResult2, ho_GraySub2;
  HObject  ho_ImageEmphasize1, ho_Rectangle, ho_SmallKReduced;
  HObject  ho_SmallK;

  // Local control variables
  HTuple  hv_tuple_k_rows, hv_tuple_k_cols, hv_ImageFiles;
  HTuple  hv_IndexImage, hv_k_rows, hv_k_cols, hv_Width, hv_Height;
  HTuple  hv_WindowHandle, hv_t1, hv_Height_Rect, hv_Width2;
  HTuple  hv_Height2, hv_Width1, hv_Height1, hv_rectange_width;
  HTuple  hv_rect_col, hv_prev_width, hv_Width4, hv_Height4;
  HTuple  hv_HorProjection, hv_VertProjection, hv_Function;
  HTuple  hv_SmoothedFunction, hv_FirstDerivative, hv_ZeroCrossings;
  HTuple  hv_SecondDerivative, hv_Max, hv_Threshold, hv_Greatereq;
  HTuple  hv_left_part_value, hv_right_part_value, hv_move_dis;
  HTuple  hv_small_K_width, hv_middle_parts, hv_middle_Y_parts;
  HTuple  hv_points_loc, hv_Y_value, hv_Sorted, hv_sort_point_index;
  HTuple  hv_index_0, hv_good_index, hv_points_num, hv_search_num;
  HTuple  hv_good_label, hv_index, hv_good_index_sorted, hv_mean_width;
  HTuple  hv_Mean_Width, hv_leftest_pos, hv_rightest_pos;
  HTuple  hv_col0, hv_col1, hv_Valid_Width, hv_Width_Rect;
  HTuple  hv_Width3, hv_Height3, hv_HorProjection1, hv_VertProjection1;
  HTuple  hv_Function1, hv_SmoothedFunction1, hv_FirstDerivative1;
  HTuple  hv_ZeroCrossings1, hv_middle_parts1, hv_middle_Y_parts1;
  HTuple  hv_Y_value1, hv_Sorted1, hv_sort_point_index1, hv_good_index1;
  HTuple  hv_search_num1, hv_good_label1, hv_good_index1_sorted;
  HTuple  hv_mean_height, hv_Mean_Height, hv_gu_value, hv_row0;
  HTuple  hv_row1, hv_FirstDerivativeReplaced, hv_Greater0;
  HTuple  hv_Index0, hv_Index1, hv_t2, hv_WidthK, hv_HeightK;
  HTuple  hv_WindowHandle1;

  //本方法是基于图像相减和灰度投影的方法进行小K图提取
  //但方法对于那些内部存在类似或相同的区域无法挑拣


  hv_tuple_k_rows.Clear();
  hv_tuple_k_rows[0] = 3;
  hv_tuple_k_rows[1] = 3;
  hv_tuple_k_rows[2] = 9;
  hv_tuple_k_rows[3] = 3;
  hv_tuple_k_rows[4] = 3;
  hv_tuple_k_rows[5] = 3;
  hv_tuple_k_rows[6] = 5;
  hv_tuple_k_rows[7] = 3;
  hv_tuple_k_rows[8] = 6;
  hv_tuple_k_rows[9] = 6;
  hv_tuple_k_rows[10] = 6;
  hv_tuple_k_rows[11] = 1;
  hv_tuple_k_rows[12] = 30;
  hv_tuple_k_rows[13] = 3;
  hv_tuple_k_rows[14] = 3;
  hv_tuple_k_rows[15] = 4;
  hv_tuple_k_rows[16] = 3;
  hv_tuple_k_rows[17] = 3;
  hv_tuple_k_rows[18] = 3;
  hv_tuple_k_rows[19] = 3;
  hv_tuple_k_rows[20] = 3;
  hv_tuple_k_rows[21] = 1;
  hv_tuple_k_rows[22] = 3;
  hv_tuple_k_rows[23] = 3;
  hv_tuple_k_rows[24] = 9;
  hv_tuple_k_cols.Clear();
  hv_tuple_k_cols[0] = 4;
  hv_tuple_k_cols[1] = 5;
  hv_tuple_k_cols[2] = 4;
  hv_tuple_k_cols[3] = 1;
  hv_tuple_k_cols[4] = 1;
  hv_tuple_k_cols[5] = 8;
  hv_tuple_k_cols[6] = 7;
  hv_tuple_k_cols[7] = 4;
  hv_tuple_k_cols[8] = 8;
  hv_tuple_k_cols[9] = 8;
  hv_tuple_k_cols[10] = 8;
  hv_tuple_k_cols[11] = 8;
  hv_tuple_k_cols[12] = 5;
  hv_tuple_k_cols[13] = 8;
  hv_tuple_k_cols[14] = 1;
  hv_tuple_k_cols[15] = 8;
  hv_tuple_k_cols[16] = 6;
  hv_tuple_k_cols[17] = 8;
  hv_tuple_k_cols[18] = 4;
  hv_tuple_k_cols[19] = 1;
  hv_tuple_k_cols[20] = 3;
  hv_tuple_k_cols[21] = 6;
  hv_tuple_k_cols[22] = 2;
  hv_tuple_k_cols[23] = 4;
  hv_tuple_k_cols[24] = 4;

  ListFiles("C:/Users/Administrator/Desktop/三倍图/Good/good", ((HTuple("files").Append("follow_links")).Append("recursive")), 
      &hv_ImageFiles);
  TupleRegexpSelect(hv_ImageFiles, (HTuple("\\.(tif|tiff|gif|bmp|jpg|jpeg|jp2|png|pcx|pgm|ppm|pbm|xwd|ima)$").Append("ignore_case")), 
      &hv_ImageFiles);
  {
  HTuple end_val10 = hv_ImageFiles.TupleLength();
  HTuple step_val10 = 1;
  for (hv_IndexImage=1; hv_IndexImage.Continue(end_val10, step_val10); hv_IndexImage += step_val10)
  {
    if (HDevWindowStack::IsOpen())
      CloseWindow(HDevWindowStack::Pop());
    hv_k_rows = HTuple(hv_tuple_k_rows[hv_IndexImage-1]);
    hv_k_cols = HTuple(hv_tuple_k_cols[hv_IndexImage-1]);
    ReadImage(&ho_Image, "C:/Users/Administrator/Desktop/三倍图/Good/good/"+hv_IndexImage);
    GetImageSize(ho_Image, &hv_Width, &hv_Height);
    SetWindowAttr("background_color","black");
    OpenWindow(0,0,hv_Width/4,hv_Height/4,0,"visible","",&hv_WindowHandle);
    HDevWindowStack::Push(hv_WindowHandle);
    if (HDevWindowStack::IsOpen())
      DispObj(ho_Image, HDevWindowStack::GetActive());

    CountSeconds(&hv_t1);

    ConvertImageType(ho_Image, &ho_Image, "uint2");

    Rgb1ToGray(ho_Image, &ho_GrayImage);

    hv_Height_Rect = hv_Height/(8*hv_k_rows);

    if (HDevWindowStack::IsOpen())
      SetDraw(HDevWindowStack::GetActive(),"margin");

    CountSeconds(&hv_t1);

    //获取第一部分
    GenRectangle2(&ho_Rectangle1, hv_Height/2, hv_Width/2, 0, hv_Width/2, hv_Height_Rect);

    ReduceDomain(ho_GrayImage, ho_Rectangle1, &ho_ImageReduced);
    CropDomain(ho_ImageReduced, &ho_ImagePart1);
    GetImageSize(ho_ImagePart1, &hv_Width2, &hv_Height2);
    //获取第二部分
    GenRectangle2(&ho_Rectangle2, (hv_Height/2)-(3*hv_Height_Rect), hv_Width/2, 0, 
        hv_Width/2, hv_Height_Rect);
    ReduceDomain(ho_GrayImage, ho_Rectangle2, &ho_ImageReduced1);
    CropDomain(ho_ImageReduced1, &ho_ImagePart2);
    ZoomImageSize(ho_ImagePart2, &ho_ImagePart2, hv_Width2, hv_Height2, "constant");

    //获取第三块矩形，增加鲁棒性
    GenRectangle2(&ho_Rectangle3, (hv_Height/2)+(3*hv_Height_Rect), hv_Width/2, 0, 
        hv_Width/2, hv_Height_Rect);
    ReduceDomain(ho_GrayImage, ho_Rectangle3, &ho_ImageReduced2);
    CropDomain(ho_ImageReduced2, &ho_ImagePart3);
    ZoomImageSize(ho_ImagePart3, &ho_ImagePart3, hv_Width2, hv_Height2, "constant");

    AbsDiffImage(ho_ImagePart1, ho_ImagePart2, &ho_ImageSub, 0.1);
    AbsDiffImage(ho_ImagePart2, ho_ImagePart3, &ho_ImageSub_1, .1);
    AbsDiffImage(ho_ImagePart1, ho_ImagePart3, &ho_ImageSub_2, .1);

    AddImage(ho_ImageSub, ho_ImageSub_1, &ho_ImageResult, 1, 0);
    AddImage(ho_ImageResult, ho_ImageSub_2, &ho_ImageResult1, 1, 0);

    GetImageSize(ho_ImageResult1, &hv_Width1, &hv_Height1);

    Rgb1ToGray(ho_ImageResult1, &ho_GraySub);
    //先获取大的ROI
    //*********************************************************************************
    hv_rectange_width = 10;

    hv_rect_col = 0;
    //记录下上一个的位置
    hv_prev_width = 0;

    if (HDevWindowStack::IsOpen())
      SetColor(HDevWindowStack::GetActive(),"yellow");

    //设置矩形的高度为GraySub的高度
    GetImageSize(ho_GraySub, &hv_Width4, &hv_Height4);

    Emphasize(ho_GraySub, &ho_ImageEmphasize, hv_Width4, hv_Height4, 1);

    //In the first one, calculate the grayhisto.
    GrayProjections(ho_ImageEmphasize, ho_ImageEmphasize, "simple", &hv_HorProjection, 
        &hv_VertProjection);
    CreateFunct1dArray(hv_VertProjection, &hv_Function);
    SmoothFunct1dGauss(hv_Function, 2, &hv_SmoothedFunction);
    DerivateFunct1d(hv_SmoothedFunction, "first", &hv_FirstDerivative);
    ZeroCrossingsFunct1d(hv_FirstDerivative, &hv_ZeroCrossings);
    DerivateFunct1d(hv_SmoothedFunction, "second", &hv_SecondDerivative);
    TupleMax(hv_SmoothedFunction, &hv_Max);


    //定义阈值为高度的一半
    hv_Threshold = hv_Max/6;
    //先除去左右两端的
    TupleGreaterEqualElem(hv_SmoothedFunction, hv_Threshold, &hv_Greatereq);
    //找到两端点
    TupleFindFirst(hv_Greatereq, 1, &hv_left_part_value);
    TupleFindLast(hv_Greatereq, 1, &hv_right_part_value);

    //定义左右偏移量，减去偏移量
    hv_move_dis = (hv_right_part_value-hv_left_part_value)/50;

    hv_left_part_value = hv_left_part_value-hv_move_dis;
    hv_right_part_value += hv_move_dis;

    //******TEST***********
    //dev_set_color ('blue')
    //disp_line (WindowHandle, 0, left_part_value, Height, left_part_value)
    //disp_line (WindowHandle, 0, right_part_value, Height, right_part_value)
    //dev_set_color ('yellow')
    //*******TEST END******

    //确定了左右边界之后，根据左右边界，确定小K图的大致宽度
    hv_small_K_width = ((hv_right_part_value-hv_left_part_value)-(hv_k_cols*50))/hv_k_cols;

    //储存除去两端剩下的
    hv_middle_parts = HTuple();
    hv_middle_Y_parts = HTuple();

    //取中间部分的几个最小值
    {
    HTuple end_val113 = (hv_ZeroCrossings.TupleLength())-1;
    HTuple step_val113 = 1;
    for (hv_points_loc=0; hv_points_loc.Continue(end_val113, step_val113); hv_points_loc += step_val113)
    {
      if (0 != (HTuple(HTuple(hv_ZeroCrossings[hv_points_loc])>hv_left_part_value).TupleAnd(HTuple(hv_ZeroCrossings[hv_points_loc])<hv_right_part_value)))
      {
        //计算中间部分点的值
        GetYValueFunct1d(hv_SmoothedFunction, HTuple(hv_ZeroCrossings[hv_points_loc]), 
            "constant", &hv_Y_value);
        hv_middle_Y_parts = hv_middle_Y_parts.TupleConcat(hv_Y_value);
        hv_middle_parts = hv_middle_parts.TupleConcat(HTuple(hv_ZeroCrossings[hv_points_loc]));
      }
    }
    }

    TupleSort(hv_middle_Y_parts, &hv_Sorted);

    //记录当前检测点的位置坐标
    hv_sort_point_index = 0;
    //先记录第一个，稍后与其比较
    TupleFindFirst(hv_middle_Y_parts, HTuple(hv_Sorted[0]), &hv_index_0);
    hv_good_index = HTuple(hv_middle_parts[hv_index_0]);

    //记录符合条件点的个数
    hv_points_num = 0;
    hv_search_num = 1;

    //这里之所以这样设置，为了加上两边界，5列6边界
    while (0 != (hv_points_num<=(hv_k_cols+1)))
    {
      TupleFindFirst(hv_middle_Y_parts, HTuple(hv_Sorted[hv_search_num]), &hv_sort_point_index);
      //如果一条线与数组中的所有线都距离较远
      hv_good_label = 1;
      {
      HTuple end_val139 = (hv_good_index.TupleLength())-1;
      HTuple step_val139 = 1;
      for (hv_index=0; hv_index.Continue(end_val139, step_val139); hv_index += step_val139)
      {
        if (0 != (((HTuple(hv_middle_parts[hv_sort_point_index])-HTuple(hv_good_index[hv_index])).TupleAbs())<(hv_small_K_width-100)))
        {
          hv_good_label = 0;
          break;
        }
      }
      }
      if (0 != (hv_good_label==1))
      {
        hv_good_index = hv_good_index.TupleConcat(HTuple(hv_middle_parts[hv_sort_point_index]));
        hv_points_num += 1;
      }
      //为了防止找不到报错，这里设置如下
      if (0 != (hv_search_num<((hv_Sorted.TupleLength())-1)))
      {
        hv_search_num += 1;
      }
      else
      {
        break;
      }
    }

    //推算出左/右边界坐标
    TupleSort(hv_good_index, &hv_good_index_sorted);
    //计算均值

    if (0 != (hv_k_cols>=2))
    {
      hv_mean_width = HTuple();
      {
      HTuple end_val163 = (hv_good_index_sorted.TupleLength())-2;
      HTuple step_val163 = 1;
      for (hv_index=0; hv_index.Continue(end_val163, step_val163); hv_index += step_val163)
      {
        hv_mean_width = hv_mean_width.TupleConcat(HTuple(hv_good_index_sorted[hv_index+1])-HTuple(hv_good_index_sorted[hv_index]));
      }
      }

      TupleMean(hv_mean_width, &hv_Mean_Width);

      hv_leftest_pos = HTuple(hv_good_index_sorted[1])-hv_Mean_Width;
      hv_rightest_pos = HTuple(hv_good_index_sorted[(hv_good_index_sorted.TupleLength())-2])+hv_Mean_Width;

      //这里替换左右边界
      TupleReplace(hv_good_index_sorted, 0, hv_leftest_pos, &hv_good_index_sorted);
      TupleReplace(hv_good_index_sorted, (hv_good_index_sorted.TupleLength())-1, 
          hv_rightest_pos, &hv_good_index_sorted);

      hv_col0 = ((const HTuple&)hv_good_index_sorted)[0];
      hv_col1 = ((const HTuple&)hv_good_index_sorted)[1];

    }
    else
    {
      //如果是单列 赋值到点
      hv_col0 = hv_left_part_value;
      hv_col1 = hv_right_part_value;
    }

    //显示
    if (0 != ((hv_good_index_sorted.TupleLength())>2))
    {
      {
      HTuple end_val187 = (hv_good_index_sorted.TupleLength())-1;
      HTuple step_val187 = 1;
      for (hv_points_num=0; hv_points_num.Continue(end_val187, step_val187); hv_points_num += step_val187)
      {
        DispLine(hv_WindowHandle, 0, HTuple(hv_good_index_sorted[hv_points_num]), 
            hv_Height, HTuple(hv_good_index_sorted[hv_points_num]));
      }
      }
    }

    //************TEST BEGIN*************************
    //重新绘制左右边界线
    //dev_set_color ('red')
    //disp_line (WindowHandle, 0, leftest_pos, Height, leftest_pos)
    //disp_line (WindowHandle, 0, rightest_pos, Height, rightest_pos)
    //************TEST END******************************


    //******************************************************************************
    //******************************************************************************

    //确定起作用的宽度
    hv_Valid_Width = hv_right_part_value-hv_left_part_value;

    hv_Width_Rect = hv_left_part_value+(hv_Valid_Width/2);

    //获取第一部分
    GenRectangle2(&ho_Rectangle3, hv_Height/2, hv_Width_Rect, 0, hv_Valid_Width/(hv_k_cols*6), 
        hv_Height/2);
    ReduceDomain(ho_GrayImage, ho_Rectangle3, &ho_ImageReduced3);
    CropDomain(ho_ImageReduced3, &ho_ImagePart3);
    GetImageSize(ho_ImagePart3, &hv_Width3, &hv_Height3);

    //获取第二部分
    GenRectangle2(&ho_Rectangle4, hv_Height/2, (hv_Width_Rect-((2*hv_Valid_Width)/(hv_k_cols*6)))+10, 
        0, hv_Valid_Width/(hv_k_cols*5), hv_Height/2);
    ReduceDomain(ho_GrayImage, ho_Rectangle4, &ho_ImageReduced4);
    CropDomain(ho_ImageReduced4, &ho_ImagePart4);
    ZoomImageSize(ho_ImagePart4, &ho_ImagePart4, hv_Width3, hv_Height3, "constant");

    //获取第三部分
    GenRectangle2(&ho_Rectangle5, hv_Height/2, (hv_Width_Rect+((2*hv_Valid_Width)/(hv_k_cols*6)))-10, 
        0, hv_Valid_Width/(hv_k_cols*5), hv_Height/2);
    ReduceDomain(ho_GrayImage, ho_Rectangle5, &ho_ImageReduced5);
    CropDomain(ho_ImageReduced5, &ho_ImagePart5);
    ZoomImageSize(ho_ImagePart5, &ho_ImagePart5, hv_Width3, hv_Height3, "constant");

    AbsDiffImage(ho_ImagePart3, ho_ImagePart4, &ho_ImageSub2, 0.1);
    AbsDiffImage(ho_ImagePart5, ho_ImagePart4, &ho_ImageSub2_1, .1);
    AbsDiffImage(ho_ImagePart3, ho_ImagePart5, &ho_ImageSub2_2, .1);

    AddImage(ho_ImageSub2, ho_ImageSub2_1, &ho_ImageResult_2, 1, 0);
    AddImage(ho_ImageResult_2, ho_ImageSub2_2, &ho_ImageResult2, 1, 0);

    Rgb1ToGray(ho_ImageResult2, &ho_GraySub2);
    Emphasize(ho_GraySub2, &ho_ImageEmphasize1, hv_Width3, hv_Height3, 1);
    //灰度投影
    GrayProjections(ho_ImageEmphasize1, ho_ImageEmphasize1, "simple", &hv_HorProjection1, 
        &hv_VertProjection1);
    CreateFunct1dArray(hv_HorProjection1, &hv_Function1);
    SmoothFunct1dGauss(hv_Function1, 2, &hv_SmoothedFunction1);
    DerivateFunct1d(hv_SmoothedFunction1, "first", &hv_FirstDerivative1);
    ZeroCrossingsFunct1d(hv_FirstDerivative1, &hv_ZeroCrossings1);


    //储存除去两端剩下的
    hv_middle_parts1 = HTuple();
    hv_middle_Y_parts1 = HTuple();

    //取中间部分的几个最小值
    {
    HTuple end_val248 = (hv_ZeroCrossings1.TupleLength())-1;
    HTuple step_val248 = 1;
    for (hv_points_loc=0; hv_points_loc.Continue(end_val248, step_val248); hv_points_loc += step_val248)
    {
      //计算中间部分点的值
      if (0 != (HTuple(hv_ZeroCrossings1[hv_points_loc])>5))
      {
        GetYValueFunct1d(hv_SmoothedFunction1, HTuple(hv_ZeroCrossings1[hv_points_loc]), 
            "constant", &hv_Y_value1);
        hv_middle_Y_parts1 = hv_middle_Y_parts1.TupleConcat(hv_Y_value1);
        hv_middle_parts1 = hv_middle_parts1.TupleConcat(HTuple(hv_ZeroCrossings1[hv_points_loc]));
      }
    }
    }

    TupleSort(hv_middle_Y_parts1, &hv_Sorted1);

    //记录符合条件点的个数
    hv_points_num = 0;
    //记录当前检测点的位置坐标
    hv_sort_point_index1 = 0;
    //先记录第一个，稍后与其比较
    TupleFindFirst(hv_middle_Y_parts1, HTuple(hv_Sorted1[0]), &hv_index_0);
    hv_good_index1 = HTuple(hv_middle_parts1[hv_index_0]);

    hv_search_num1 = 1;

    //有时候需要减去2，有时候需要减去1

    while (0 != (hv_points_num<(hv_k_rows-2)))
    {
      TupleFindFirst(hv_middle_Y_parts1, HTuple(hv_Sorted1[hv_search_num1]), &hv_sort_point_index1);
      //如果一条线与数组中的所有线都距离较远
      hv_good_label1 = 1;
      {
      HTuple end_val275 = (hv_good_index1.TupleLength())-1;
      HTuple step_val275 = 1;
      for (hv_index=0; hv_index.Continue(end_val275, step_val275); hv_index += step_val275)
      {
        if (0 != (((HTuple(hv_middle_parts1[hv_sort_point_index1])-HTuple(hv_good_index1[hv_index])).TupleAbs())<100))
        {
          hv_good_label1 = 0;
          break;
        }
      }
      }

      if (0 != (hv_good_label1==1))
      {
        hv_good_index1 = hv_good_index1.TupleConcat(HTuple(hv_middle_parts1[hv_sort_point_index1]));
        //disp_line (WindowHandle, middle_parts1[sort_point_index1], 0, middle_parts1[sort_point_index1], Width)
        hv_points_num += 1;
      }
      //为了防止找不到报错，这里设置如下
      if (0 != (hv_search_num1<((hv_Sorted1.TupleLength())-1)))
      {
        hv_search_num1 += 1;
      }
      else
      {
        break;
      }

    }

    //推算出上、下边界坐标
    TupleSort(hv_good_index1, &hv_good_index1_sorted);
    //计算均值

    if (0 != (hv_k_rows>2))
    {
      hv_mean_height = HTuple();
      {
      HTuple end_val302 = (hv_good_index1_sorted.TupleLength())-2;
      HTuple step_val302 = 1;
      for (hv_index=0; hv_index.Continue(end_val302, step_val302); hv_index += step_val302)
      {
        hv_mean_height = hv_mean_height.TupleConcat(HTuple(hv_good_index1_sorted[hv_index+1])-HTuple(hv_good_index1_sorted[hv_index]));
      }
      }

      TupleMean(hv_mean_height, &hv_Mean_Height);

      //判断如果均值与估值相差太大
      hv_gu_value = hv_Height/hv_k_rows;
      if (0 != (((hv_Mean_Height-hv_gu_value)/hv_gu_value)>0.3))
      {
        //说明计算的有问题
        //再加一个
        while (0 != (hv_search_num1<((hv_Sorted1.TupleLength())-1)))
        {
          TupleFindFirst(hv_middle_Y_parts1, HTuple(hv_Sorted1[hv_search_num1]), 
              &hv_sort_point_index1);
          hv_good_label1 = 1;
          {
          HTuple end_val316 = (hv_good_index1.TupleLength())-1;
          HTuple step_val316 = 1;
          for (hv_index=0; hv_index.Continue(end_val316, step_val316); hv_index += step_val316)
          {
            if (0 != (((HTuple(hv_middle_parts1[hv_sort_point_index1])-HTuple(hv_good_index1[hv_index])).TupleAbs())<100))
            {
              hv_good_label1 = 0;
              break;
            }
          }
          }
          if (0 != (hv_good_label1==1))
          {
            hv_good_index1 = hv_good_index1.TupleConcat(HTuple(hv_middle_parts1[hv_sort_point_index1]));
            break;
          }
          hv_search_num1 += 1;
        }
      }
      //即使距离估计正确，个数有可能估计错


      TupleSort(hv_good_index1, &hv_good_index1_sorted);

      hv_row0 = ((const HTuple&)hv_good_index1_sorted)[0];
      hv_row1 = ((const HTuple&)hv_good_index1_sorted)[1];

    }
    else
    {
      //如果是单行 赋值到点
      //找到一阶导数不为0的首点，和一阶导数为0的末点
      TupleReplace(hv_FirstDerivative1, HTuple::TupleGenSequence(0,5,1), 0, &hv_FirstDerivativeReplaced);
      TupleGreaterElem(hv_FirstDerivativeReplaced, 0.05, &hv_Greater0);
      TupleFindFirst(hv_Greater0, 1, &hv_Index0);
      hv_row0 = hv_Index0;

      TupleFindLast(hv_Greater0, 1, &hv_Index1);

      hv_row1 = hv_Index1;
    }


    //显示
    {
    HTuple end_val352 = (hv_good_index1.TupleLength())-1;
    HTuple step_val352 = 1;
    for (hv_points_num=0; hv_points_num.Continue(end_val352, step_val352); hv_points_num += step_val352)
    {
      if (0 != ((hv_good_index1.TupleLength())!=1))
      {
        DispLine(hv_WindowHandle, HTuple(hv_good_index1_sorted[hv_points_num]), 0, 
            HTuple(hv_good_index1_sorted[hv_points_num]), hv_Width);
      }
    }
    }

    //显示计算时间
    set_display_font(hv_WindowHandle, 16, "mono", "true", "false");
    CountSeconds(&hv_t2);
    WriteString(hv_WindowHandle, ("Time is: "+((hv_t2-hv_t1)*1000))+" ms ");

    //显示小K图

    GenRectangle1(&ho_Rectangle, hv_row0, hv_col0, hv_row1, hv_col1);
    ReduceDomain(ho_Image, ho_Rectangle, &ho_SmallKReduced);
    CropDomain(ho_SmallKReduced, &ho_SmallK);
    GetImageSize(ho_SmallK, &hv_WidthK, &hv_HeightK);
    dev_open_window_fit_image(ho_SmallK, 0, 0, -1, -1, &hv_WindowHandle1);
    if (HDevWindowStack::IsOpen())
      DispObj(ho_SmallK, HDevWindowStack::GetActive());

    // stop(...); only in hdevelop

    if (HDevWindowStack::IsOpen())
      CloseWindow(HDevWindowStack::Pop());

  }
  }
}


#ifndef NO_EXPORT_APP_MAIN

#ifdef __APPLE__
// On OS X systems, we must have a CFRunLoop running on the main thread in
// order for the HALCON graphics operators to work correctly, and run the
// action function in a separate thread. A CFRunLoopTimer is used to make sure
// the action function is not called before the CFRunLoop is running.
// Note that starting with macOS 10.12, the run loop may be stopped when a
// window is closed, so we need to put the call to CFRunLoopRun() into a loop
// of its own.
HTuple      gStartMutex;
H_pthread_t gActionThread;
HBOOL       gTerminate = FALSE;

static void timer_callback(CFRunLoopTimerRef timer, void *info)
{
  UnlockMutex(gStartMutex);
}

static Herror apple_action(void **parameters)
{
  // Wait until the timer has fired to start processing.
  LockMutex(gStartMutex);
  UnlockMutex(gStartMutex);

  try
  {
    action();
  }
  catch (HException &exception)
  {
    fprintf(stderr,"  Error #%u in %s: %s\n", exception.ErrorCode(),
            (const char *)exception.ProcName(),
            (const char *)exception.ErrorMessage());
  }

  // Tell the main thread to terminate itself.
  LockMutex(gStartMutex);
  gTerminate = TRUE;
  UnlockMutex(gStartMutex);
  CFRunLoopStop(CFRunLoopGetMain());
  return H_MSG_OK;
}

static int apple_main(int argc, char *argv[])
{
  Herror                error;
  CFRunLoopTimerRef     Timer;
  CFRunLoopTimerContext TimerContext = { 0, 0, 0, 0, 0 };

  CreateMutex("type","sleep",&gStartMutex);
  LockMutex(gStartMutex);

  error = HpThreadHandleAlloc(&gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleAlloc failed: %d\n", error);
    exit(1);
  }

  error = HpThreadCreate(gActionThread,0,apple_action);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadCreate failed: %d\n", error);
    exit(1);
  }

  Timer = CFRunLoopTimerCreate(kCFAllocatorDefault,
                               CFAbsoluteTimeGetCurrent(),0,0,0,
                               timer_callback,&TimerContext);
  if (!Timer)
  {
    fprintf(stderr,"CFRunLoopTimerCreate failed\n");
    exit(1);
  }
  CFRunLoopAddTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);

  for (;;)
  {
    HBOOL terminate;

    CFRunLoopRun();

    LockMutex(gStartMutex);
    terminate = gTerminate;
    UnlockMutex(gStartMutex);

    if (terminate)
      break;
  }

  CFRunLoopRemoveTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);
  CFRelease(Timer);

  error = HpThreadHandleFree(gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleFree failed: %d\n", error);
    exit(1);
  }

  ClearMutex(gStartMutex);
  return 0;
}
#endif

int main(int argc, char *argv[])
{
  int ret = 0;

  try
  {
#if defined(_WIN32)
    SetSystem("use_window_thread", "true");
#elif defined(__linux__) && !defined(__arm__)
    XInitThreads();
#endif

    // Default settings used in HDevelop (can be omitted) 
    SetSystem("width", 512);
    SetSystem("height", 512);

#ifndef __APPLE__
    action();
#else
    ret = apple_main(argc,argv);
#endif
  }
  catch (HException &exception)
  {
    fprintf(stderr,"  Error #%u in %s: %s\n", exception.ErrorCode(),
            (const char *)exception.ProcName(),
            (const char *)exception.ErrorMessage());
    ret = 1;
  }
  return ret;
}

#endif


#endif


